<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>More Internet Clutter</title><link href="http://chanhosuh.github.io/" rel="alternate"></link><link href="http://chanhosuh.github.io/feeds/all.atom.xml" rel="self"></link><id>http://chanhosuh.github.io/</id><updated>2018-05-13T00:00:00-04:00</updated><entry><title>Setting up a GitHub Pages site with Travis integration</title><link href="http://chanhosuh.github.io/setting-up-a-github-pages-site-with-travis-integration.html" rel="alternate"></link><published>2017-04-30T00:00:00-04:00</published><updated>2017-04-30T00:00:00-04:00</updated><author><name>Chan-Ho Suh</name></author><id>tag:chanhosuh.github.io,2017-04-30:/setting-up-a-github-pages-site-with-travis-integration.html</id><summary type="html">&lt;p&gt;In the spirit of "it's better to get started on something trivial than procrastinate
forever on something deep", my first post for this blog will be on
setting up a blog with &lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;.  I did not find it quite trivial, 
especially since I wanted my site to build automatically …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In the spirit of "it's better to get started on something trivial than procrastinate
forever on something deep", my first post for this blog will be on
setting up a blog with &lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;.  I did not find it quite trivial, 
especially since I wanted my site to build automatically via a static site generator once I pushed a blog post in Markdown to GitHub.&lt;/p&gt;
&lt;p&gt;There are several steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Set up GitHub source repo and target repo (your GitHub pages site repo)&lt;/li&gt;
&lt;li&gt;Copy &lt;a href="http://getpelican.com"&gt;Pelican&lt;/a&gt; config files to your GitHub source repo&lt;/li&gt;
&lt;li&gt;Set up &lt;a href="http://travis-ci.org"&gt;Travis&lt;/a&gt; on source repo&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For future reference, my GitHub source repo is &lt;a href="https://github.com/chanhosuh/chanhosuh.github.io-src"&gt;here&lt;/a&gt; and &lt;a href="https://github.com/chanhosuh/chanhosuh.github.io"&gt;this&lt;/a&gt; is the target (site) repo.&lt;/p&gt;
&lt;p&gt;As you will see, the approach is to push your Markdown files to the source repo, which will be configured for Travis CI.  Travis will then detect the changes, run a build using a static site generator, and deploy the output files to your target repo, which will then reflect at your GitHub Pages domain.&lt;/p&gt;
&lt;h3&gt;Set up GitHub repositories&lt;/h3&gt;
&lt;p&gt;Setting up a GitHub Pages site is pretty simple.  Create a repo called &lt;code&gt;&amp;lt;GitHub username&amp;gt;.github.io&lt;/code&gt;.  This will create what GitHub calls an individual/organization site (the other option is to create a project site; I won't describe how to do this).  Check that the settings for this repo has GitHub Pages activated. Once you've done it, you will have a domain like mine, &lt;GitHub username&gt;.github.io.  This site will be built from the files in this repo, which I will call the &lt;em&gt;target&lt;/em&gt; repo.&lt;/p&gt;
&lt;p&gt;Now create another repo.  For simplicity, I will assume that like me, you call it &lt;code&gt;&amp;lt;GitHub username&amp;gt;.github.io-src&lt;/code&gt;.  This is the &lt;em&gt;source&lt;/em&gt; repo.  &lt;/p&gt;
&lt;h3&gt;Copy Pelican files to source repo&lt;/h3&gt;
&lt;p&gt;Now that your repositories are set up, you need a static site generator.
GitHub recommends Jekyll, which is what I initially tried.  Ultimately, I decided to 
go with &lt;a href="http://getpelican.com"&gt;Pelican&lt;/a&gt;.  Since my goal in using a static
site generator was to have an overall understanding of how my site was being built 
and served, it appealed to me that Pelican is written in Python (Jekyll is written in Ruby).&lt;/p&gt;
&lt;p&gt;Technically, you don't need to install Pelican.  What you need to push to your repository are the following files generated by a Pelican install: &lt;code&gt;pelicanconf.py&lt;/code&gt;, &lt;code&gt;publishconf.py&lt;/code&gt;, and &lt;code&gt;Makefile&lt;/code&gt;.  The Travis deploy script (see below) will need these files to configure Pelican.  Also, the deploy assumes your content is in a &lt;code&gt;content&lt;/code&gt; directory.&lt;/p&gt;
&lt;h3&gt;Configuring Travis CI for source repo&lt;/h3&gt;
&lt;p&gt;First go to the &lt;a href="https://travis-ci.org/"&gt;Travis site&lt;/a&gt;, login with your GitHub account and turn on your source repo so Travis is watching it.  Disable build on pull.  &lt;/p&gt;
&lt;p&gt;Once you've set up your GitHub commits to trigger a Travis build, you need to create a &lt;code&gt;.travis.yml&lt;/code&gt; file at the root of your repo.  &lt;a href="https://github.com/chanhosuh/chanhosuh.github.io-src/blob/master/.travis.yml"&gt;Mine&lt;/a&gt; is a pretty generic one.  Note it does a pip install of &lt;code&gt;pelican&lt;/code&gt; and &lt;code&gt;markdown&lt;/code&gt;.  I also use a different theme than the default; the brute-force method I used was to just copy over all the theme files to the repo and in the deploy script (see below) use the &lt;code&gt;pelican-themes&lt;/code&gt; command to install it.&lt;/p&gt;
&lt;p&gt;Note the yml has the line: &lt;code&gt;after_success: ./deploy.sh&lt;/code&gt;.  This deploy script should be executable.  I stole the &lt;a href="https://github.com/chanhosuh/chanhosuh.github.io-src/blob/master/deploy.sh"&gt;deploy script&lt;/a&gt; from &lt;a href="danielfrg.github.io-source"&gt;Daniel Rodriguez's setup&lt;/a&gt;, since he has already done the hard work of figuring out the details of environment variables and so forth.  What his script does is clone the target repo to the Travis build server, copy over the Pelican output, and then git push it all. &lt;/p&gt;
&lt;p&gt;The last part of the yml has an encrypted key used by Travis to push to your target repo.  So you need to go into your user settings --&amp;gt; developer settings --&amp;gt; Personal access tokens, where you will be able to "generate new token" and allow "Travis CI" to use it with &lt;a href="https://docs.travis-ci.com/user/github-oauth-scopes/"&gt;various permissions&lt;/a&gt;.  You can't use this token directly as it will be exposed in your public source directory, so you need to encrypt it.  Travis provides a &lt;a href="https://docs.travis-ci.com/user/encryption-keys/"&gt;tool&lt;/a&gt; to do this, but unfortunately(?) you need to install it through a ruby gem.  &lt;/p&gt;
&lt;p&gt;Assuming you already have Ruby gems installed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gem install travis
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now from the root of your source repo, run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;travis encrypt GH_TOKEN=your_token --add
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;where &lt;code&gt;your_token&lt;/code&gt; is your authentication token.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;--add&lt;/code&gt; option adds something like the following to your &lt;code&gt;.travis.yml&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;global&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;secure&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ebuvzbMDBTB6EWTZ5ngz3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;GzBJSWLTE&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;tEgpzw&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;wpIkc3G2B&lt;/span&gt;&lt;span class="sr"&gt;/0MJ2dVNfiVViynw3iHWnJjta1C4AW+afpE8JR1qnkQyjhyO6i4501gBHaKCeHshEhjySTpw7W4aKH2JHWYryY50AI0+9MIjwuhlfB4U3MEY5G391qLNKOUuwXx3wlsnsgnRZ1FBANJHFdpLWI16Hnm7EytpiJmCt74iVTe0fzpwRRn2AbH1RGNIPF8T1xB0vMx5bRXu9XIQnYu/4q4unVyrPTQOY2SNu5qvS/UajZaycw3DpCSdlcgbw2XTC6DQQDlWV23aXKG8H8HWQwHQoHvK4HXzil4+mstqZPv5EuBZIHoBH7F1qpnnGiuAJRDlakOraPVKIaE22yF+ory55SnGJuZg95vSmAMeKfwnMPd3DGND5ipCskaINrWbvCtwLcyPHwLo+e5DpdS7RJsMreN7wdyVjdQO2y+WEWk1pEkiC/IGnO/ItoU+ZwmHKGgjA9rGFJrW7iwdhw3rVZnA/hroh6TXQhat8qnXOdrrbzW5tag4ObjXLmiCmD1UNzcJmJvs2XxLIytHujXXwX+FNGAylQ52C9WsMxIsCT0ErjVHjKM2AuQERn0t7nO40gf0jMJ2kX+TyHer++9GzJJTZxR/mhsA3q1Kn6rC5qkxUMzXL/&lt;/span&gt;&lt;span class="n"&gt;K4PPAX6pPfheg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Phew, so you've set up Travis!  Now all that's left to do is post some content, tweak Pelican....&lt;/p&gt;
&lt;h4&gt;Useful references&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="danielfrg.github.io-source"&gt;Daniel Rodriguez's source repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://siongui.github.io/2016/01/05/deploy-website-by-pelican-travis-ci-github-pages/"&gt;Siong-Ui Te - Theory and Practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>12 coins problem:</title><link href="http://chanhosuh.github.io/12-coins-problem.html" rel="alternate"></link><published>2016-02-08T00:00:00-05:00</published><updated>2018-05-13T00:00:00-04:00</updated><author><name>Chan-Ho Suh</name></author><id>tag:chanhosuh.github.io,2016-02-08:/12-coins-problem.html</id><summary type="html">&lt;p&gt;You are given 12 coins that look identical and a pair of scales.
One of the coins is fake and has a different weight than the
others.  Your challenge is to use the scales at most three times
to determine the fake coin and whether it is light or heavier …&lt;/p&gt;</summary><content type="html">&lt;p&gt;You are given 12 coins that look identical and a pair of scales.
One of the coins is fake and has a different weight than the
others.  Your challenge is to use the scales at most three times
to determine the fake coin and whether it is light or heavier
than a real coin.  You can weigh any group of coins against another
using the scales to see which is heavier or if they balance, but
you cannot measure the actual weights of the coins.&lt;/p&gt;
&lt;p&gt;The code we are constructing uses the alphabet { O, R, L } with
each word being three letters, i.e. ORL, LLR, ROO...&lt;/p&gt;
&lt;p&gt;The code must satisfy the following four conditions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1. It does not contain OOO
2. It does not contain a pair of words that are reflections
   of each other, e.g. LRR is the reflection of RLL, OLO is
   the reflection of ORO, etc.
3. For each position 1-3, there are equal numbers of L&amp;#39;s and
   R&amp;#39;s.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Any such code determines a method of placing coins on the
scales in the three weighings: we assign a coin to each codeword,
e.g. coin #1 assigned to ORR.&lt;/p&gt;
&lt;p&gt;The letters give the location of the coin for each weighing:
    - O means "off the scale"
    - L means "on the left side of the scale"
    - R means "on the right side of the scale"&lt;/p&gt;
&lt;p&gt;So coin #1 will be off the scale, then on the left side, and
finally on the right side for the three weighings.&lt;/p&gt;
&lt;p&gt;The above conditions on the code then imply that our placement
method satisfies the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1. Every coin is placed on the scale for at least one
   weighing.
2. No two coins are placed at the same location for every
   weighing.
3. No two coins are placed on opposite sides and taken off
   the scale together for every weighing.
4. Each weighing places the same number of coins on each
   side of the scale.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now suppose we do the three weighings according to our placement
method.&lt;/p&gt;
&lt;p&gt;For example, we might get OLL.  This means the first weighing
balanced the sides. In particular, the fake coin is off the scale.
The second weighing pushed down the left side.  This means that
(assuming the fake is heavier) the fake coin was on the left side
of the scale.  The last weighing did the same, so the fake coin
was again on the left side.  If the fake is lighter, then the
conclusion is it was on the right sides for the last two weighings.&lt;/p&gt;
&lt;p&gt;Whether the fake is heavier or lighter, it's clear the three
weighings give a codeword which then corresponds exactly to the
coin which was placed according to the codeword (or its reflection).&lt;/p&gt;
&lt;p&gt;The above method of using codewords may appear mysterious at first
glance, but follows entirely naturally from an information-theoretic
viewpoint.&lt;/p&gt;
&lt;p&gt;The system we are learning about is 12 coins, with one being fake.
Since the fake coin can be one of 12 coins and the fake coin can have
two states, light or heavy, there are 24 possible states of the system.
The placement method for the coins and the three weighings are
effectively an encoding scheme that codes the starting state of the
system into a three letter codeword as above.&lt;/p&gt;
&lt;p&gt;There are 27 possible codewords.  In order to find a solution the
problem, we must be able to invert the encoding ("decode uniquely")
to obtain the starting state.  Invertibility imposes conditions.
For example, if two coins are always either off the scale or on the
same side of a scale, there is no way to distinguish the states where
one coin is fake from the other being fake.  In other words, in order
to distinguish each starting state from another, we need to make sure
no two coins follow each other around in our placement of the coins.
In fact we need more than that.  We need to make sure no two coins
mirror each other's movements; if two coins are always on opposite
sides of one another, there is no way to distinguish which is the fake,
as we don't know if the fake is heavy or light.&lt;/p&gt;
&lt;p&gt;These conditions on how the coins can be placed lead to the above
conditions on the codewords.  In particular, in order for there to be
enough codewords to cover the 24 system states (and keeping in mind
that we place the same number on each side of the scale) we must place
four coins on each side of the scale at each weighing.  Any less and
there wouldn't be enough codewords.  And there are not enough codewords
to allow 5 or more to be weighed on each side (given the first letter,
there are only 9 words starting with R, and 9 starting with L, half of
them are reflections and not allowed, so we really only have 9 allowable
words to determine which coins get placed on a scale, but only an even
number of coins can be placed on the scale (half on each side), so the
most we can have is 4 on each side at a time.&lt;/p&gt;
&lt;p&gt;So from an information theoretic viewpoint, we see very clearly why we
must divide up the 12 coins into three groups of four, something which
may strike us as very mysterious when using trial-and-error to derive
the solution!&lt;/p&gt;
&lt;p&gt;Another nice thing about viewing the problem this way, is it lets us
generalize to more coins and more weighings.  If we allow four weighings,
what's the largest number of coins for which we can determine the fake
coin?  With three weighings, we saw that 12 is the optimal number.
Anymore, and we simplywould not have enough codewords.&lt;/p&gt;
&lt;p&gt;For four weighings, we have 3^4 = 81 possible codewords.  As before
OOOO is not allowed, so that leaves us with 80 possibilities.  Again,
there are 40 reflection pairs, so we can have at most 40 coins.  Note
that 27 codewords (modulo reflections) are allowed for coins being
placed on the scale, and 13 for off the scale.  Again the restriction
that we allow only equal numbers to be placed on each side of the scale
means that 13 is the largest that can be placed on each side.  So we
have 26 coins being placed on a scale at once and that leaves 13 for
off the scale, for a total of 39 coins.&lt;/p&gt;
&lt;p&gt;Going through this reasoning more rigorously and keeping track of the
arithmetic, we conclude that the number of coins can be at most
(3^n - 3) / 2 where n is the number of weighings.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;- n = 3,  # coins = 12
- n = 4,  # coins = 39
- n = 5,  # coins = 120
- etc..
&lt;/pre&gt;&lt;/div&gt;</content></entry></feed>